import { Request, Response } from 'express';
import { Booking } from './bookings.entity';
import { BookingsPostgresRepository } from './bookings.postgres.repository';

const bookingsRepository = new BookingsPostgresRepository();

export class BookingsController {
  // HU09: Get booking history for authenticated client
  async findAllBookings(req: Request, res: Response) {
    const clientId = parseInt(req.query.clientId as string, 10);

    if (isNaN(clientId)) {
      res.status(400).json({
        errorMessage: 'Invalid clientId',
        errorCode: 'INVALID_CLIENT_ID',
      });
      return;
    }

    const status = req.query.status as string;
    const dateFrom = req.query.date_from ? new Date(req.query.date_from as string) : undefined;
    const dateTo = req.query.date_to ? new Date(req.query.date_to as string) : undefined;

    if ((dateFrom && isNaN(dateFrom.getTime())) || (dateTo && isNaN(dateTo.getTime()))) {
      res.status(400).json({
        errorMessage: 'Invalid date format',
        errorCode: 'INVALID_DATE',
      });
      return;
    }

    const bookings = await bookingsRepository.findAll({
      clientId,
      status,
      dateFrom,
      dateTo,
    });

    if (!bookings) {
      res.status(500).json({
        errorMessage: 'Internal server error',
        errorCode: 'INTERNAL_SERVER_ERROR',
      });
      return;
    }

    res.json(bookings);
  }

  // HU10: Get professional's daily bookings
  async findProfessionalBookings(req: Request, res: Response) {
    const role = req.query.role as string;
    if (role !== 'professional') {
      res.status(403).json({
        errorMessage: 'Access forbidden: Professional role required',
        errorCode: 'FORBIDDEN',
      });
      return;
    }

    const date = req.query.date ? new Date(req.query.date as string) : new Date();
    if (isNaN(date.getTime())) {
      res.status(400).json({
        errorMessage: 'Invalid date format',
        errorCode: 'INVALID_DATE',
      });
      return;
    }

    const bookings = await bookingsRepository.findByDate(date);
    if (!bookings) {
      res.status(500).json({
        errorMessage: 'Internal server error',
        errorCode: 'INTERNAL_SERVER_ERROR',
      });
      return;
    }

    res.json(bookings);
  }

  // HU04: Create a new booking
  async addBooking(req: Request, res: Response) {
    const input = req.body.sanitizedInput;
    const clientId = parseInt(req.body.clientId as string, 10);
    const userStatus = req.body.status as string;

    if (!clientId || userStatus !== 'approved') {
      res.status(401).json({
        errorMessage: 'Unauthorized or unapproved user',
        errorCode: 'UNAUTHORIZED',
      });
      return;
    }

    const isAvailable = await bookingsRepository.checkAvailability(
      input.serviceId,
      input.date,
      input.startTime,
    );
    if (!isAvailable) {
      res.status(409).json({
        errorMessage: 'Slot not available',
        errorCode: 'SLOT_UNAVAILABLE',
      });
      return;
    }

    const newBooking = new Booking(
      undefined, // id is generated by the database
      input.clientId,
      input.serviceId,
      input.date,
      input.startTime,
      input.endTime,
      input.status || 'pending',
      input.treatmentId,
      input.createdAt,
      input.updatedAt,
    );

    const savedBooking = await bookingsRepository.add(newBooking);
    if (!savedBooking) {
      res.status(500).json({
        errorMessage: 'Internal server error',
        errorCode: 'INTERNAL_SERVER_ERROR',
      });
      return;
    }

    res.status(201).json({ data: savedBooking });
  }

  // HU06: Reprogram a booking
  async updateBooking(req: Request, res: Response) {
    const bookingId = parseInt(req.params.id, 10);
    const clientId = parseInt(req.body.clientId as string, 10);
    const input = req.body.sanitizedInput;

    if (isNaN(bookingId)) {
      res.status(400).json({
        errorMessage: 'Invalid booking ID',
        errorCode: 'INVALID_BOOKING_ID',
      });
      return;
    }

    if (!clientId) {
      res.status(401).json({
        errorMessage: 'Unauthorized access',
        errorCode: 'UNAUTHORIZED',
      });
      return;
    }

    const existingBooking = await bookingsRepository.findOne(bookingId);
    if (!existingBooking || existingBooking.clientId !== clientId) {
      res.status(404).json({
        errorMessage: 'Booking not found or not owned by user',
        errorCode: 'BOOKING_NOT_FOUND',
      });
      return;
    }

    const isAvailable = await bookingsRepository.checkAvailability(
      input.serviceId,
      input.date,
      input.startTime,
      bookingId, // Exclude current booking from conflict check
    );
    if (!isAvailable) {
      res.status(409).json({
        errorMessage: 'Slot not available',
        errorCode: 'SLOT_UNAVAILABLE',
      });
      return;
    }

    const updatedBooking = new Booking(
      bookingId,
      input.clientId,
      input.serviceId,
      input.date,
      input.startTime,
      input.endTime,
      input.status || existingBooking.status,
      existingBooking.treatmentId,
      existingBooking.createdAt,
      new Date(), // Update timestamp
    );

    const savedBooking = await bookingsRepository.update(bookingId, updatedBooking);
    if (!savedBooking) {
      res.status(500).json({
        errorMessage: 'Internal server error',
        errorCode: 'INTERNAL_SERVER_ERROR',
      });
      return;
    }

    res.json({
      data: savedBooking,
      message: 'Booking reprogrammed successfully',
    });
  }

  // HU05: Cancel a booking
  async deleteBooking(req: Request, res: Response) {
    const bookingId = parseInt(req.params.id, 10);
    const clientId = parseInt(req.query.clientId as string, 10);

    if (isNaN(bookingId)) {
      res.status(400).json({
        errorMessage: 'Invalid booking ID',
        errorCode: 'INVALID_BOOKING_ID',
      });
      return;
    }

    if (!clientId) {
      res.status(401).json({
        errorMessage: 'Unauthorized access',
        errorCode: 'UNAUTHORIZED',
      });
      return;
    }

    const existingBooking = await bookingsRepository.findOne(bookingId);
    if (!existingBooking || existingBooking.clientId !== clientId) {
      res.status(404).json({
        errorMessage: 'Booking not found or not owned by user',
        errorCode: 'BOOKING_NOT_FOUND',
      });
      return;
    }

    // Check if cancellation is allowed (e.g., 24 hours before)
    const now = new Date();
    const bookingDateTime = new Date(`${existingBooking.date}T${existingBooking.startTime}`);
    const hoursDifference = (bookingDateTime.getTime() - now.getTime()) / (1000 * 60 * 60);
    if (hoursDifference < 24) {
      res.status(403).json({
        errorMessage: 'Cancellation not allowed within 24 hours',
        errorCode: 'CANCELLATION_NOT_ALLOWED',
      });
      return;
    }

    const deletedBooking = await bookingsRepository.delete(bookingId);
    if (!deletedBooking) {
      res.status(500).json({
        errorMessage: 'Internal server error',
        errorCode: 'INTERNAL_SERVER_ERROR',
      });
      return;
    }

    res.json({
      message: 'Booking cancelled successfully',
      id: bookingId,
    });
  }
}